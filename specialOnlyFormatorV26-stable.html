<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WEBæ–‡å­—æå–å™¨</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: Arial, sans-serif;
            margin: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #48c9b0; /* è–„è·ç¶  */
        }
        textarea, input[type="text"] {
            background-color: #2c2c2c;
            color: #ffffff;
            border: 1px solid #555;
            padding: 10px;
            margin: 5px;
            width: 100%;
            max-width: 600px;
            border-radius: 5px;
        }
        textarea {
            height: 150px;
            resize: vertical;
        }
        .condition-group {
            display: flex;
            align-items: center;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .condition-group input[type="text"] {
            width: 110px;
        }
        button {
            background-color: #6a0dad; /* ç´«è‰² */
            color: #ffffff;
            border: none;
            padding: 5px 5px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }
        button:hover {
            background-color: #7b1fa2;
        }
        .remove-btn {
            background-color: #d32f2f; /* ç´…è‰²ï¼Œç”¨æ–¼åˆªé™¤ */
        }
        .remove-btn:hover {
            background-color: #e53935;
        }
        #conditions-container {
            width: 100%;
            max-width: 600px;
        }
        .not-inputs {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .not-pair {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        input[type="file"] {
            display: none;
        }
        label {
            background-color: #6a0dad;
            color: #ffffff;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }
        label:hover {
            background-color: #7b1fa2;
        }
        .filter-controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }
        #postFilters {
            width: 100px;
        }
        
        /* æ–°å¢çš„onlyTextæ¨£å¼ */
        .checkbox-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            width: 100%;
            max-width: 600px;
        }
        .checkbox-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: #2a2a2a;
        }
        .checkbox-item input {
            margin-right: 5px;
        }
        .checkbox-item label {
            margin-right: 5px;
            font-size: 10px;
        }
        .row-toggle {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: #3a3a3a;
            margin-left: 10px;
        }
        .row-toggle label {
            margin-left: 5px;
            font-size: 10px;
        }
        /* æ®µè½é¢œè‰² */
        .color-0 { color: #ff7b7b; }
        .color-1 { color: #7bb4ff; }
        .color-2 { color: #7bff8c; }
        .color-3 { color: #ffdd7b; }
        .color-4 { color: #d67bff; }
        .color-5 { color: #7bfff3; }
        .color-6 { color: #ff7be8; }
        .color-7 { color: #a3ff7b; }
        .para-block {
            margin-bottom: 1em;
        }
        #outputDiv {
            width: 100%;
            min-height: 150px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 16px;
            white-space: pre-wrap;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <h1>WEBæ–‡å­—æå–å™¨</h1>
    <input type="text" id="urlInput" placeholder="è«‹è¼¸å…¥ç¶²å€...">
    <textarea id="inputHtml" placeholder="è«‹è²¼ä¸Šæ‚¨çš„HTMLç¨‹å¼ç¢¼..."></textarea>
    <div id="conditions-container">
        <div class="condition-group">
            <input type="text" class="tag-a" placeholder="é–‹å§‹æ¨™ç±¤ (ä¾‹å¦‚ï¼š<p>)">
            <input type="text" class="tag-b" placeholder="çµæŸæ¨™ç±¤ (ä¾‹å¦‚ï¼š</p>)">
            <button onclick="addCondition()">+</button>
            <button onclick="addNotCondition(this)">NOT</button>
            <button class="remove-btn" onclick="removeConditionGroup(this)">X</button>
        </div>
    </div>
    <div class="filter-controls">
        <label for="loadFilter">è¼‰å…¥éæ¿¾</label>
        <input type="file" id="loadFilter" accept=".txt" onchange="loadFilter(event)">
        <button onclick="saveFilter()">ä¿å­˜éæ¿¾</button>
        <button onclick="extractText()">è½‰æ›</button>
        <input type="text" id="postFilters" placeholder="å¾Œç½®éæ¿¾æ¢ä»¶ (ä»¥é€—è™Ÿåˆ†éš”ï¼Œä¾‹å¦‚ï¼š's,abc)">
    </div>
    
    <!-- ä¿®æ”¹å¾Œçš„è¼¸å‡ºå€åŸŸ -->
    <div id="checkboxContainer" class="checkbox-container"></div>
    <div id="outputDiv"></div>
    <button onclick="saveAsTxt()">å„²å­˜ç‚ºTXT</button>

    <script>
        // æ–°å¢çš„è®Šé‡
        let currentParagraphs = [];
        let removedIndices = new Set();
        const colorClasses = ['color-0', 'color-1', 'color-2', 'color-3', 'color-4', 'color-5', 'color-6', 'color-7'];

        function addCondition() {
            const container = document.getElementById('conditions-container');
            const newGroup = document.createElement('div');
            newGroup.className = 'condition-group';
            newGroup.innerHTML = `
                <input type="text" class="tag-a" placeholder="é–‹å§‹æ¨™ç±¤ (ä¾‹å¦‚ï¼š<p>)">
                <input type="text" class="tag-b" placeholder="çµæŸæ¨™ç±¤ (ä¾‹å¦‚ï¼š</p>)">
                <button onclick="addCondition()">+</button>
                <button onclick="addNotCondition(this)">NOT</button>
                <button class="remove-btn" onclick="removeConditionGroup(this)">X</button>
            `;
            container.appendChild(newGroup);
        }

        function addNotCondition(button) {
            const group = button.parentElement;
            let notInputs = group.querySelector('.not-inputs');
            if (!notInputs) {
                notInputs = document.createElement('div');
                notInputs.className = 'not-inputs';
                group.appendChild(notInputs);
            }
            const newNotPair = document.createElement('div');
            newNotPair.className = 'not-pair';
            newNotPair.innerHTML = `
                <input type="text" class="tag-not-start" placeholder="æ’é™¤é–‹å§‹æ¨™ç±¤æˆ–æ–‡å­— (ä¾‹å¦‚ï¼š<span> æˆ– 's)">
                <input type="text" class="tag-not-end" placeholder="æ’é™¤çµæŸæ¨™ç±¤ (ä¾‹å¦‚ï¼š</span>ï¼Œå¯ç•™ç©º)">
                <button class="remove-btn" onclick="removeNotPair(this)">X</button>
            `;
            notInputs.appendChild(newNotPair);
        }

        function removeConditionGroup(button) {
            const group = button.parentElement;
            group.remove();
        }

        function removeNotPair(button) {
            const notPair = button.parentElement;
            const notInputs = notPair.parentElement;
            notPair.remove();
            if (notInputs.children.length === 0) {
                notInputs.remove();
            }
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\']/g, '\\$&');
        }

        function encodeSpecialChars(str) {
            if (typeof str !== 'string') return str;
            return str
                .replace(/"/g, 'ğŸ˜„')
                .replace(/>/g, 'ğŸ˜')
                .replace(/<\//g, 'ğŸ˜Š');
        }

        function decodeSpecialChars(str) {
            if (typeof str !== 'string') return str;
            return str
                .replace(/ğŸ˜„/g, '"')
                .replace(/ğŸ˜/g, '>')
                .replace(/ğŸ˜Š/g, '</');
        }

        function extractText() {
            const htmlInput = document.getElementById('inputHtml').value;
            const conditions = document.querySelectorAll('.condition-group');
            const postFiltersInput = document.getElementById('postFilters').value.trim();
            let matches = [];
            let errorMessages = [];

            Array.from(conditions).forEach((group, groupIndex) => {
                const tagA = group.querySelector('.tag-a').value.trim();
                const tagB = group.querySelector('.tag-b').value.trim();
                const notPairs = group.querySelectorAll('.not-pair');

                if (tagA && tagB) {
                    try {
                        const escapedTagA = escapeRegExp(tagA);
                        const escapedTagB = escapeRegExp(tagB);
                        const regexAB = new RegExp(`${escapedTagA}(.*?)${escapedTagB}`, 'gs');

                        let match;
                        while ((match = regexAB.exec(htmlInput)) !== null) {
                            let content = match[1];

                            notPairs.forEach(pair => {
                                const tagNotStart = pair.querySelector('.tag-not-start').value.trim();
                                const tagNotEnd = pair.querySelector('.tag-not-end').value.trim();
                                if (tagNotStart) {
                                    try {
                                        const escapedNotStart = escapeRegExp(tagNotStart);
                                        const escapedNotEnd = tagNotEnd ? escapeRegExp(tagNotEnd) : '';
                                        const regexNot = new RegExp(
                                            escapedNotEnd ? `${escapedNotStart}.*?${escapedNotEnd}` : escapedNotStart,
                                            'gs'
                                        );
                                        content = content.replace(regexNot, '');
                                    } catch (e) {
                                        errorMessages.push(`ç„¡æ•ˆçš„NOTæ¢ä»¶: ${tagNotStart}-${tagNotEnd}`);
                                    }
                                }
                            });

                            if (content.trim()) {
                                matches.push({ content: content.trim(), groupIndex });
                            }
                        }
                    } catch (e) {
                        errorMessages.push(`ç„¡æ•ˆçš„æ¢ä»¶çµ„: ${tagA}-${tagB}`);
                    }
                }
            });

            const seen = new Set();
            let extracted = [];
            matches.forEach(match => {
                if (!seen.has(match.content)) {
                    seen.add(match.content);
                    extracted.push(match);
                }
            });

            if (postFiltersInput) {
                const postFilters = postFiltersInput.split(',')
                    .map(f => f.trim())
                    .filter(f => f);
                if (postFilters.length > 0) {
                    extracted = extracted.filter(({ content }) => {
                        return !postFilters.some(filter => {
                            try {
                                const escapedFilter = escapeRegExp(filter);
                                const regexFilter = new RegExp(escapedFilter, 'g');
                                return regexFilter.test(content);
                            } catch (e) {
                                errorMessages.push(`ç„¡æ•ˆçš„å¾Œç½®éæ¿¾æ¢ä»¶: ${filter}`);
                                return false;
                            }
                        });
                    });
                }
            }

            extracted.sort((a, b) => a.groupIndex - b.groupIndex);

            currentParagraphs = extracted.map(item => item.content);
            removedIndices = new Set();
            
            updateCheckboxUI();
            updateOutput();

            if (errorMessages.length > 0) {
                alert(`è™•ç†éç¨‹ä¸­ç™¼ç¾ä»¥ä¸‹å•é¡Œï¼š\n${errorMessages.join('\n')}`);
            }
            if (extracted.length === 0 && matches.length > 0) {
                alert('è­¦å‘Šï¼šæ‰€æœ‰æå–å…§å®¹è¢«éæ¿¾æ¢ä»¶ç§»é™¤ï¼Œè«‹æª¢æŸ¥æ¢ä»¶çµ„ã€NOTæ¢ä»¶æˆ–å¾Œç½®éæ¿¾è¨­ç½®ï¼');
            }
        }

        // æ–°å¢çš„å‡½æ•¸
        function updateCheckboxUI() {
            const container = document.getElementById('checkboxContainer');
            container.innerHTML = '';
            
            const rows = [];
            for (let i = 0; i < currentParagraphs.length; i += 5) {
                rows.push(currentParagraphs.slice(i, i + 5));
            }
            
            rows.forEach((row, rowIndex) => {
                const rowContainer = document.createElement('div');
                rowContainer.className = 'checkbox-row';
                
                row.forEach((para, indexInRow) => {
                    const globalIndex = rowIndex * 5 + indexInRow;
                    const colorClass = colorClasses[globalIndex % colorClasses.length];
                    
                    const checkboxItem = document.createElement('div');
                    checkboxItem.className = `checkbox-item ${colorClass}`;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `para-${globalIndex}`;
                    checkbox.checked = !removedIndices.has(globalIndex);
                    checkbox.onchange = function() {
                        if (this.checked) {
                            removedIndices.delete(globalIndex);
                        } else {
                            removedIndices.add(globalIndex);
                        }
                        updateOutput();
                    };
                    
                    const label = document.createElement('label');
                    label.htmlFor = `para-${globalIndex}`;
                    label.textContent = `æ®µè½ ${globalIndex + 1}`;
                    label.className = colorClass;
                    
                    checkboxItem.appendChild(checkbox);
                    checkboxItem.appendChild(label);
                    rowContainer.appendChild(checkboxItem);
                });
                
                if (row.length > 0) {
                    const rowToggle = document.createElement('div');
                    rowToggle.className = 'row-toggle';
                    
                    const masterCheckbox = document.createElement('input');
                    masterCheckbox.type = 'checkbox';
                    masterCheckbox.checked = row.every((_, indexInRow) => {
                        const globalIndex = rowIndex * 5 + indexInRow;
                        return !removedIndices.has(globalIndex);
                    });
                    masterCheckbox.onchange = function() {
                        row.forEach((_, indexInRow) => {
                            const globalIndex = rowIndex * 5 + indexInRow;
                            if (this.checked) {
                                removedIndices.delete(globalIndex);
                            } else {
                                removedIndices.add(globalIndex);
                            }
                        });
                        updateCheckboxUI();
                        updateOutput();
                    };
                    
                    const label = document.createElement('label');
                    label.textContent = 'å…¨é¸';
                    
                    rowToggle.appendChild(masterCheckbox);
                    rowToggle.appendChild(label);
                    rowContainer.appendChild(rowToggle);
                }
                
                container.appendChild(rowContainer);
            });
        }

        function updateOutput() {
            const outputDiv = document.getElementById('outputDiv');
            outputDiv.innerHTML = '';
            
            currentParagraphs.forEach((para, index) => {
                if (!removedIndices.has(index)) {
                    const colorClass = colorClasses[index % colorClasses.length];
                    const paraBlock = document.createElement('div');
                    paraBlock.className = `para-block ${colorClass}`;
                    paraBlock.textContent = para;
                    outputDiv.appendChild(paraBlock);
                }
            });
        }

        function saveFilter() {
            const url = document.getElementById('urlInput').value.trim();
            const postFilters = document.getElementById('postFilters').value.trim();
            const conditions = document.querySelectorAll('.condition-group');
            let filterData = { url: encodeSpecialChars(url), postFilters: encodeSpecialChars(postFilters), conditions: [] };

            conditions.forEach(group => {
                const tagA = group.querySelector('.tag-a').value.trim();
                const tagB = group.querySelector('.tag-b').value.trim();
                let groupData = { tagA: encodeSpecialChars(tagA), tagB: encodeSpecialChars(tagB), notPairs: [] };
                const notPairs = group.querySelectorAll('.not-pair');
                notPairs.forEach(pair => {
                    const tagNotStart = pair.querySelector('.tag-not-start').value.trim();
                    const tagNotEnd = pair.querySelector('.tag-not-end').value.trim();
                    if (tagNotStart || tagNotEnd) {
                        groupData.notPairs.push({
                            tagNotStart: encodeSpecialChars(tagNotStart),
                            tagNotEnd: encodeSpecialChars(tagNotEnd)
                        });
                    }
                });
                if (tagA || tagB || groupData.notPairs.length > 0) {
                    filterData.conditions.push(groupData);
                }
            });

            if (filterData.conditions.length === 0 && !filterData.url && !filterData.postFilters) {
                alert('æ²’æœ‰éæ¿¾æ¢ä»¶ã€ç¶²å€æˆ–å¾Œç½®éæ¿¾æ¢ä»¶å¯å„²å­˜ï¼');
                return;
            }

            const blob = new Blob([JSON.stringify(filterData, null, 2)], { type: 'text/plain' });
            const urlBlob = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = urlBlob;
            a.download = 'filter_conditions.txt';
            a.click();
            URL.revokeObjectURL(urlBlob);
        }

        function loadFilter(event) {
            const file = event.target.files[0];
            if (!file) {
                alert('æœªé¸æ“‡æª”æ¡ˆï¼');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const filterData = JSON.parse(e.target.result);
                    if (typeof filterData !== 'object' || filterData === null) {
                        throw new Error('æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼šæ‡‰ç‚ºæœ‰æ•ˆçš„JSONç‰©ä»¶');
                    }
                    if (!Array.isArray(filterData.conditions)) {
                        throw new Error('æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼šç¼ºå°‘æˆ–ç„¡æ•ˆçš„æ¢ä»¶é™£åˆ—ï¼ˆconditionsï¼‰');
                    }

                    const container = document.getElementById('conditions-container');
                    const urlInput = document.getElementById('urlInput');
                    const postFiltersInput = document.getElementById('postFilters');
                    container.innerHTML = '';

                    urlInput.value = decodeSpecialChars(typeof filterData.url === 'string' ? filterData.url : '');
                    postFiltersInput.value = decodeSpecialChars(typeof filterData.postFilters === 'string' ? filterData.postFilters : '');

                    filterData.conditions.forEach((groupData, index) => {
                        if (!groupData || typeof groupData !== 'object') {
                            throw new Error(`ç„¡æ•ˆçš„æ¢ä»¶çµ„æ ¼å¼ï¼ˆç´¢å¼• ${index}ï¼‰`);
                        }

                        const newGroup = document.createElement('div');
                        newGroup.className = 'condition-group';

                        const inputA = document.createElement('input');
                        inputA.type = 'text';
                        inputA.className = 'tag-a';
                        inputA.placeholder = 'é–‹å§‹æ¨™ç±¤ (ä¾‹å¦‚ï¼š<p>)';
                        inputA.value = decodeSpecialChars(groupData.tagA || '');

                        const inputB = document.createElement('input');
                        inputB.type = 'text';
                        inputB.className = 'tag-b';
                        inputB.placeholder = 'çµæŸæ¨™ç±¤ (ä¾‹å¦‚ï¼š</p>)';
                        inputB.value = decodeSpecialChars(groupData.tagB || '');

                        const addButton = document.createElement('button');
                        addButton.textContent = '+';
                        addButton.onclick = addCondition;

                        const notButton = document.createElement('button');
                        notButton.textContent = 'NOT';
                        notButton.onclick = function() { addNotCondition(this); };

                        const removeButton = document.createElement('button');
                        removeButton.className = 'remove-btn';
                        removeButton.textContent = 'X';
                        removeButton.onclick = function() { removeConditionGroup(this); };

                        newGroup.appendChild(inputA);
                        newGroup.appendChild(inputB);
                        newGroup.appendChild(addButton);
                        newGroup.appendChild(notButton);
                        newGroup.appendChild(removeButton);

                        if (Array.isArray(groupData.notPairs) && groupData.notPairs.length > 0) {
                            const notInputs = document.createElement('div');
                            notInputs.className = 'not-inputs';
                            groupData.notPairs.forEach((pair, pairIndex) => {
                                if (!pair || typeof pair !== 'object') {
                                    throw new Error(`ç„¡æ•ˆçš„NOTæ¢ä»¶æ ¼å¼ï¼ˆæ¢ä»¶çµ„ ${index}ï¼ŒNOTæ¢ä»¶ ${pairIndex}ï¼‰`);
                                }

                                const newNotPair = document.createElement('div');
                                newNotPair.className = 'not-pair';

                                const inputNotStart = document.createElement('input');
                                inputNotStart.type = 'text';
                                inputNotStart.className = 'tag-not-start';
                                inputNotStart.placeholder = 'æ’é™¤é–‹å§‹æ¨™ç±¤æˆ–æ–‡å­— (ä¾‹å¦‚ï¼š<span> æˆ– \'s)';
                                inputNotStart.value = decodeSpecialChars(pair.tagNotStart || '');

                                const inputNotEnd = document.createElement('input');
                                inputNotEnd.type = 'text';
                                inputNotEnd.className = 'tag-not-end';
                                inputNotEnd.placeholder = 'æ’é™¤çµæŸæ¨™ç±¤ (ä¾‹å¦‚ï¼š</span>ï¼Œå¯ç•™ç©º)';
                                inputNotEnd.value = decodeSpecialChars(pair.tagNotEnd || '');

                                const removeNotButton = document.createElement('button');
                                removeNotButton.className = 'remove-btn';
                                removeNotButton.textContent = 'X';
                                removeNotButton.onclick = function() { removeNotPair(this); };

                                newNotPair.appendChild(inputNotStart);
                                newNotPair.appendChild(inputNotEnd);
                                newNotPair.appendChild(removeNotButton);
                                notInputs.appendChild(newNotPair);
                            });
                            if (notInputs.children.length > 0) {
                                newGroup.appendChild(notInputs);
                            }
                        }

                        container.appendChild(newGroup);
                    });

                    if (container.children.length === 0) {
                        addCondition();
                    }
                } catch (err) {
                    alert('è¼‰å…¥éæ¿¾æ¢ä»¶å¤±æ•—ï¼š' + err.message);
                }
            };
            reader.onerror = function() {
                alert('è®€å–æª”æ¡ˆå¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æœ‰æ•ˆï¼');
            };
            reader.readAsText(file);
        }

        function saveAsTxt() {
            let outputText = '';
            
            currentParagraphs.forEach((para, index) => {
                if (!removedIndices.has(index)) {
                    outputText += para + '\n\n';
                }
            });

            if (!outputText.trim()) {
                alert('æ²’æœ‰æ–‡å­—å¯å„²å­˜ï¼');
                return;
            }

            const blob = new Blob([outputText.trim()], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'æå–æ–‡å­—.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>